# Brax Training Viewer for Real-Time Policy Visualization

This project is developed during the Google Summer of Code 2025.

Reinforcement Learning (RL) training in Brax operates at high performance, utilizing JAX for efficient parallelized training. However, due to the nature of JAXâ€™s computation model, training occurs in a highly abstracted and batched manner, making it challenging to inspect agent behavior in real-time. Currently, users must either wait until training finishes to evaluate policies or extract rollout data manually, which is inefficient and restricts debugging capabilities. A Brax Training Viewer would empower users to visualize the evolution of the policy while training is ongoing, bridging the gap between RL research and practical interpretability.

The Brax Training Viewer offers an interactive, real-time visualization tool for monitoring reinforcement learning (RL) policies during training, utilizing the official PPO training function from Brax. This package allows users to synchronize the training with a MuJoCo-based viewer, showcasing the effect of the actions taken by the RL policy across numerous parallel environments. Users can benefit from real-time action updates, which enable them to track the evolution of the policy over time. A toggle option to enable or disable synchronization will be provided to enhance performance, allowing users to pause visualization and speed up the training process temporarily.

As this tool extends the official Brax PPO training function, it ensures seamless compatibility with current reinforcement learning pipelines. This allows for easy implementation without changing existing RL workflows, making it an excellent choice for researchers and practitioners needing to visualize, debug, and analyze RL policies in Brax with minimal configuration.

## Outcomes

* **Synchronized MuJoCo Visualization with Brax Training**: Extract actions generated by the policy network at each training step and apply them to a parallel running MuJoCo simulation.
* **Support Parallel Environments**: The viewer will visualize multiple parallel agents, reflecting the exact training conditions in Brax.
* **Allow Enable/Disable Rendering**: Since the copy process from GPU to CPU slows down the training process, users can dynamically enable or disable the data transfer to have high-speed training without visual feedback or keep visualization synchronized at the cost of slower training.

## Installation and Setup

### Conda
-   (Optionally) install Python virtual environment [conda](https://www.anaconda.com/docs/getting-started/miniconda/main)
-   (Optionally) create a virtual environment `conda create -n test python=3.10`
-   `conda activate test`
-   `cd` to the root folder of this repo
-   run `git submodule update --init --recursive`
-   run `pip install .`
-   run `pip install -r requirements.txt `
-   (Optionally) install Jax with hardware acceleration: `pip install -U "jax[cuda12]"` or `pip install -U "jax[cuda11]"` or `pip install -U "jax[tpu]"`
-   You can try the examples in the `demo/` folder, for example: `python demo/cartpole.py`
-   Open a web browser and go to `http://127.0.0.1:8000/` for the viewer.

### UV
[UV](https://github.com/astral-sh/uv) is an extremely fast Python package installer and resolver, written in Rust.
-   `cd` to the root folder of this repo
-   run `git submodule update --init --recursive`
-   Install uv `pip install uv`
-   Create a virtual environment `uv venv`
-   Activate the virtual environment `source .venv/bin/activate`
-   Install dependencies `uv pip install -r requirements.txt`
-   Install the project `uv pip install .`
-   You can try the examples provided in the `demo/` folder, for instance: `python demo/training_example.py`
-   Open a web browser and navigate to `http://127.0.0.1:8000/` to see the viewer.

## How to Use

Integrating the viewer into your existing Brax training script is straightforward. The core idea is to instantiate the appropriate viewer, wrap your training environment with `ViewerWrapper`, and then pass the wrapped environment to the training function.

### For a Single Environment Visualization

This is the simplest use case, ideal for standard Brax environments. The following example demonstrates how to visualize a generic agent.

1.  **Import necessary modules**:
    ```python
    from braxviewer.WebViewer import WebViewer
    from braxviewer.brax.brax.envs.wrappers.viewer import ViewerWrapper
    from braxviewer.brax.brax.training.agents.ppo import train as ppo
    from brax.training.agents.ppo import networks as ppo_networks
    # from your_project import YourBraxEnvironment # Import your custom env
    ```

2.  **Create the Viewer and Wrap the Environment**:
    ```python
    # Load your robot's XML model string. Examples can be found in the
    # official Brax repository: https://github.com/google/brax/tree/main/brax/envs/assets
    xml_model = "..." 

    # Instantiate the viewer and run it in the background
    viewer = WebViewer(xml=xml_model)
    viewer.run()

    # Create an instance of your custom Brax environment
    env_for_evaluation = YourBraxEnvironment(xml_model=xml_model)

    # Wrap the environment to link it with the viewer
    env_for_training = ViewerWrapper(env=env_for_evaluation, viewer=viewer)
    ```

3.  **Call the Training Function**:
    Directly call the `ppo.train` function with the wrapped environment and other training parameters.

    ```python
    # Define the PPO network
    make_networks_factory = ppo_networks.make_ppo_networks

    # Call the training function directly
    make_policy_fn, params, _ = ppo.train(
        environment=env_for_training,
        eval_env=env_for_evaluation, # Use the original env for evaluation
        num_timesteps=40000,
        episode_length=300,
        num_envs=1, # Single environment
        normalize_observations=True,
        network_factory=make_networks_factory
        # ... add other ppo parameters as needed
    )
    ```

### For Batched (Parallel) Environment Visualization

To visualize multiple environments running in parallel, use `WebViewerBatched`. This viewer automatically handles the arrangement of agents in a 3D grid.

1.  **Import modules**:
    ```python
    from braxviewer.WebViewerBatched import WebViewerBatched
    from braxviewer.brax.brax.envs.wrappers.viewer import ViewerWrapper
    from braxviewer.brax.brax.training.agents.ppo import train as ppo
    from brax.training.agents.ppo import networks as ppo_networks
    # from your_project import YourBraxEnvironment # Import your custom env
    ```

2.  **Create the Batched Viewer and Wrap the Environment**:
    `WebViewerBatched` only needs the number of environments and the base model XML.

    ```python
    num_parallel_envs = 8
    
    # Load your robot's XML model string. Examples can be found in the
    # official Brax repository: https://github.com/google/brax/tree/main/brax/envs/assets
    xml_model = "..." 

    # Instantiate the batched viewer with the number of envs and the model
    viewer = WebViewerBatched(
        num_envs=num_parallel_envs,
        xml=xml_model
    )
    viewer.run()

    # Create an instance of your custom Brax environment
    env_for_evaluation = YourBraxEnvironment(xml_model=xml_model)

    # Wrap the environment to link it with the viewer
    env_for_training = ViewerWrapper(env=env_for_evaluation, viewer=viewer)
    ```

3.  **Call the Training Function**:
    The training happens on the original environment definition. The `ViewerWrapper` and Brax's training function handle the parallelization and visualization.

    ```python
    # Define the PPO network
    make_networks_factory = ppo_networks.make_ppo_networks
    
    # Call the training function directly
    make_policy_fn, params, _ = ppo.train(
        environment=env_for_training,
        eval_env=env_for_evaluation,
        num_envs=num_parallel_envs,
        num_timesteps=40000,
        episode_length=300,
        normalize_observations=True,
        network_factory=make_networks_factory
        # ... add other ppo parameters as needed
    )
    ```
